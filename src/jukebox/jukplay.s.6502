beebem=FALSE;							Set to true if running in BeebEm for debugging
									;	Otherwise, set to false if running on native hardware
ORG &2500;

INCLUDE "lib\beeb.h.6502";				Contains definitions for the MOS API calls, etc.
 
\\zero page variables
irq1v_old=&70;			(&70 and &71)
irq2v_old=&70;			(&70 and &71);					We don't need to intercept both IRQ vectors, it is always one or the other
mem_ptr=&72;			(&72 and &73);					Location in memory currently being played
delay=&74;				(&74 and &75);					Outstanding duration of current delay (if not zero)
load_page=&76
top_page=&77;											This is the page above the top of the circular buffer (i.e. the buffer doesn't extend into top_page)
flags=&78;												Bit 0 - set if EOF reached
													;	Bit 1 - set if end of tune reached
													;	Bit 2 - set if 
													;	Bit 3 - set if escape key has been pressed
													;	Bit 4 - set if a (relevant) key has been pressed
													;	Bit 5 - set if 
													;	Bit 6 - set if
													;	Bit 7 - set if
													
evntv_old=&79;			(&79 and &7A)
filename_address=&7B;	(&7B, &7C, &7D and &7E)			Pointer to the <fsp> parsed to the commmand

.start
	PHP:PHA:TXA:PHA:TYA:PHA;		preserve all the registers on the stack	
	
\\intercept interrupts
	SEI;							disable interrupts
	LDA irq1v;						preserve existing IRQV
	STA irq1v_old
	LDA irq1v+1
	STA irq1v_old+1
	LDA #LO(irq_handler);			redirect IRQV to our IRQ handler
	STA irq1v;						INTERCEPTING IRQ1V
	LDA #HI(irq_handler)
	STA irq1v+1
	CLI;							re-enable interrupt

\\set up evntv for ESCAPE key
	LDA evntv
	STA evntv_old
	LDA evntv+1
	STA evntv_old+1
	LDA #LO(event_handler)
	STA evntv
	LDA #HI(event_handler)
	STA evntv+1

\\enable escape events
	LDA #&0E;			enable event
	LDX #6;				escape event
	JSR osbyte
	TXA
	BEQ escape_not_set
	LDA old_event_status
	ORA #%00000100;			set bit 2
	STA old_event_status
.escape_not_set

\\enable character buffer events
	LDA #&0E;			enable event
	LDX #2;				character buffer event
	JSR osbyte
	TXA
	BEQ character_not_set
	LDA old_event_status
	ORA #%00100000;			set bit 5
	STA old_event_status
.character_not_set

\\get value for top_page
	LDA #&84
	JSR osbyte;						On exit, X and Y contain the HIMEM address (X=low byte, Y=high byte)
	STY top_page

\\set value for control_pages_to_read
	TYA
	SEC
	SBC #HI(head_page)
	STA control_pages_to_read
	
\\clear all flags
	LDA #0
	STA flags

\\get filename	
	LDA #1
	LDX #filename_address
	LDY #0
	JSR osargs

\\check for a 'null' filename; if so, return syntax instructions and end
	LDX #0
	LDA (filename_address, X)
	CMP #&0D;				termination string
	BNE not_null
	LDX #LO(syntax_error)
	LDY #HI(syntax_error)
	JMP error
.not_null

IF beebem
	\\skip card check because there can't be a card connected to BeebEm
ELSE
\\detect presence of BeebOPL card
\\there haa got to be much more efficient code than this
{
	SEI;										this procedure will generate unwanted interrupts
	LDA #&04: STA ymaddr: LDA #&60: STA ymdata;	Reset timers 1 and 2
	LDA #&04: STA ymaddr: LDA #&80: STA ymdata;	Reset the IRQ
	LDA ymaddr: AND #&E0: STA scratch_a;		Read status register. Save the result. 
											;	You should AND the result bytes with &E0h because
											;	the unused bits are undefined.
	LDA #&02: STA ymaddr: LDA #&FF: STA ymdata;	Set timer 1 to &FF.
	LDA #&04: STA ymaddr: LDA #&21: STA ymdata;	Unmask and start timer 1.
	LDX #48;									Each loop lasts 5 cycles (2.5μsec); so 32=80μsec, 48=120μsec
.delay_loop
	DEX
	BNE delay_loop;								Wait in a delay loop for at least 80μsec.
	LDA ymaddr: AND #&E0: STA scratch_b;		Read status register. Save the result. 
											;	You should AND the result bytes with &E0 because
											;	the unused bits are undefined.
	LDA #&04: STA ymaddr: LDA #&60: STA ymdata
	LDA #&04: STA ymaddr: LDA #&80: STA ymdata;	Reset timers 1 and 2 and IRQ as above.
	CLI;										re-enable interrupts
											;	Test the results of the two reads
	LDA scratch_a: BNE card_absent			;	the first should be 0, 
	LDA scratch_b: CMP #&C0: BEQ card_present;	the second should be &C0.
.card_absent
	LDX #LO(no_card)
	LDY #HI(no_card)
	JMP error
.card_present
}	
ENDIF

\\check for "-TEST" switch (if we have got this far, there must be a working card)
{
	LDY #0
.loop
	LDA (filename_address), Y
	CMP test, Y
	BNE not_test
	INY
	CPY #5
	BNE loop
	LDX #LO(card_ok)
	LDY #HI(card_ok)
	JMP error
.test
	EQUS "-TEST"
.not_test
}

\\test for escape before commencing long disk read
{	LDA flags
	AND #%00001000; 			test bit 3 for escape
	BEQ no_escape
	LDX #LO(escape)
	LDY #HI(escape)
	JMP error
.no_escape
}	
\\test for f9 key press
{	LDA flags
	AND #%00010000; 			test bit 4 for character event
	BEQ no_key
	LDX #LO(f9_key)
	LDY #HI(f9_key)
	JMP error
.no_key
}

\\get file length
	LDA filename_address
	STA osfile_filename_address
	LDA filename_address+1
	STA osfile_filename_address+1
	LDA #5;								get catalogue entry
	LDX #LO(osfile_block)
	LDY #HI(osfile_block)
	JSR osfile
	BNE file_found;						A=0 if not found (I am assuming that the Z returns correctly conditioned)
\\report error
	LDX #LO(not_found)
	LDY #HI(not_found)
	JMP error
.file_found

\\check if file will fit in memory
	LDA osfile_length+3
	BNE too_big
	LDA osfile_length+2
	BNE too_big
	LDA top_page;						this is the top of available memory
	SEC;								prepare for subtraction
	SBC #HI(head_page);					this is where data loads
\\A now contains the number of available pages
	CMP osfile_length+1;				there are three possible outcomes
									;	Z is set - there are exactly the correct number of pages - will only fit if osfile_length=0
									;	C is set (must only check after checking Z) - there is enough room
									;   neither C nor Z is set - there is not enough room
	BEQ check_remaining_bytes;			branch if Z set first
	BCC too_big;						if C is not set then there is not enough_room
	JMP	file_fits
.check_remaining_bytes
	LDA osfile_length
	BNE too_big

.file_fits
\\now we need to load the full file
	LDA #LO(head_page)
	STA osfile_load_address
	LDA #HI(head_page)
	STA osfile_load_address+1
	LDA #0
	STA osfile_load_indicator;			tell osfile to use the load address we are specifying
	LDA #&FF;							load file
	JSR osfile
\\iindicate that we have got to the end of the file
	LDA flags
	ORA #%00000001;			set bit 0 (EOF reached)
	STA flags
	JMP data_in_memory
.too_big

\\open file for sequential access
	LDA #&40;				OPENIN
	LDX filename_address
	LDY filename_address+1
	JSR osfind
	BNE file_opened
\\report error
	LDX #LO(error_opening)
	LDY #HI(error_opening)
	JMP error
.file_opened
	STA control_file_handle

\\get first few pages of data
	LDA #4;					read block using PTR#
	LDX #LO(control_block)
	LDY #HI(control_block)
	\\the other values are already pre-programmed in the control block
	\\actually not really, it's all just zeros
	\\can we do this another way and fill the control block by software
	\\or would that ironically increase the size of the executable file
	CLC
	JSR osgbpb
	BCC initial_flush;		carry flag is set on exit if attempted to read beyond EOF
\\handle EOF
	LDA flags
	ORA #%00000001;			set bit 0 (EOF reached)
	STA flags

.data_in_memory	
\\check if DRO file
{
	LDX #0
.loop
	LDA signature, X
	CMP check_signature, X
	BNE DRO_check_fail
	INX
	CPX #8
	BNE loop
	JMP DRO_check_pass
.DRO_check_fail
	LDX #LO(not_DRO)
	LDY #HI(not_DRO)
	JMP error
.DRO_check_pass
}

\\check version number
	LDA version_major
	CMP #2
	BNE version_check_fail
	LDA version_major+1
	BNE version_check_fail
	LDA version_minor
	BNE version_check_fail
	LDA version_minor+1
	BNE version_check_fail
	JMP version_check_pass
.version_check_fail
	LDX #LO(wrong_version)
	LDY #HI(wrong_version)
	JMP error
.version_check_pass

\\check for hardware type
	LDA hardware_type
	BEQ OPL2
	LDX #LO(wrong_hardware)
	LDY #HI(wrong_hardware)
	JMP error
.OPL2

\\check for compression
	LDA compression
	BEQ not_compressed
	LDX #LO(compressed)
	LDY #HI(compressed)
	JMP error
.not_compressed

\\YM3812 flush
.initial_flush
	JSR flush
	
\\setup delay
	LDA #0
	STA delay
	STA delay+1
	
\\initialize mem_ptr
	CLC
	LDA #LO(cmd_table)
	ADC cmd_table_size
	STA mem_ptr
	LDA #HI(cmd_table)
	ADC #0
	STA mem_ptr+1

\\disable ADC sampling
	LDA #&10
	LDX #0;					no ADC sampling
	JSR osbyte
	STX old_ADC;			the old value is returned in X
	
\\setup timer (YM3812)
	LDA #&04;					
	STA ymaddr
	LDA #&60;
	STA ymdata;				mask (reset) both timers
	LDA #&80;				reset IRQ (i.e. enable interrupts)
	STA ymdata
	LDA #&02;
	STA ymaddr
	LDA #244;				timer 1 has a resolution of 80 microseconds and counts up. So 244 = 256-244 = 12*80 = 960ms
	STA ymdata
	LDA #&04
	STA ymaddr
	LDA #&21;				turn on timer 1 (and mask timer 2)
	STA ymdata

\\setup on screen timer
\\place the colons
	LDA #':'
	STA bottom_row+34
	LDA #'.'
	STA bottom_row+37

\\calculate timer value
\\we need to divide the timer value from the header by 10
\\this will crash if we have a tune that lasts longer than &FFFF hundredths of a second (i.e. more than 10 minutes 55 seconds )
	
\\load length_MS into dividend_lo and dividend_hi
	LDA length_MS
	STA dividend_lo
	LDA length_MS+1
	STA dividend_lo+1
	LDA length_MS+2
	STA dividend_hi
	LDA length_MS+3
	STA dividend_hi+1
	
\\load 10 into divisor
	LDA #10
	STA divisor
	LDA #0
	STA divisor+1
	
\\now do the division
	JSR long_division
	
\\copy result into duration
	LDA quotient
	STA duration
	LDA quotient+1
	STA duration+1
	LDA #0
	STA duration+2
	STA duration+3
	STA duration+4

\\calculate the inverse of this (interval timer counts up)	
	SEC
	LDA #0
	SBC duration
	STA duration
	LDA #0
	SBC duration+1
	STA duration+1
	LDA #0
	SBC duration+2
	STA duration+2
	LDA #0
	SBC duration+3
	STA duration+3
	LDA #0
	SBC duration+4
	STA duration+4
	
\\put value in interval timer
	LDA #&4;			write interval timer
	LDX #LO(duration)
	LDY #HI(duration)
	JSR osword
	
\\enable timer zero events
	LDA #&0E;			enable event
	LDX #5;				timer event
	JSR osbyte
	TXA
	BEQ timer_zero_not_set
	LDA old_event_status
	ORA #%00000001;			set bit 0
	STA old_event_status
.timer_zero_not_set

\\enable vsync events
	LDA #&0E;			enable event
	LDX #4;				vsync event
	JSR osbyte
	TXA
	BEQ vsync_not_set
	LDA old_event_status
	ORA #%00000010;			set bit 1
	STA old_event_status
.vsync_not_set

.head_page_loop
\\test for escape
{	LDA flags
	AND #%00001000; 			test bit 3 for escape
	BEQ no_escape
	LDX #LO(escape)
	LDY #HI(escape)
	JMP error
.no_escape
}
\\test for f9 key press
{	LDA flags
	AND #%00010000; 			test bit 4 for character event
	BEQ no_key
	LDX #LO(f9_key)
	LDY #HI(f9_key)
	JMP error
.no_key
}
\\if end of tune need to go to end
	LDA flags
	AND #%00000010; 			test bit 1 for end of tune
	BNE end_game
\\if end of file need to bypass loop - IS THIS NECESSARY? - IF EOF ALREADY, WE ARE NEVER GOING TO GET PAST HEAD PAGE - YES IF FILE IS CORRUPT AND TOO SHORT
	AND #%00000001; 			test bit 0 for EOF
	BNE head_page_loop
	LDA #HI(head_page)
	CMP mem_ptr+1
	BEQ head_page_loop
	
\\set load_page to beginning of buffer
	LDA #HI(buff_page)
	STA load_page
	STA control_load_page

	
.main_loop
\\test for escape
{	LDA flags
	AND #%00001000; 			test bit 3 for escape
	BEQ no_escape
	LDX #LO(escape)
	LDY #HI(escape)
	JMP error
.no_escape
}
\\test for f9 key press
{	LDA flags
	AND #%00010000; 			test bit 4 for character event
	BEQ no_key
	LDX #LO(f9_key)
	LDY #HI(f9_key)
	JMP error
.no_key
}
\\TO DO what to do if player 'laps' the circular buffer ahead of slow disk reads
\\if end of tune need to go to end
	LDA flags
	AND #%00000010; 			test bit 1 for end of tune
	BNE end_game
\\if end of file need to bypass loop - IS THIS NECESSARY? - IF EOF ALREADY, WE ARE NEVER GOING TO GET PAST HEAD PAGE - YES IF FILE IS CORRUPT AND TOO SHORT
	LDA flags
	AND #%00000001; 			test bit 0 for EOF
	BNE main_loop
	LDA load_page
	CMP mem_ptr+1
	BEQ main_loop
	
\\get next page
	LDA #1;					set control_pages_to_read to 1
	STA control_pages_to_read
	LDA load_page
	STA control_load_page
	LDA #4;					read block using PTR#
	LDX #LO(control_block)
	LDY #HI(control_block)
	\\the other values are already pre-programmed in the control block
	CLC
	JSR osgbpb
	BCC inc_load_page;		carry flag is set on exit if attempted to read beyond EOF
\\handle EOF
	LDA flags
	ORA #%00000001;			set bit 0
	STA flags
	
.inc_load_page
	INC load_page
	
\\check if we have gone beyond the buffer	
	LDA load_page
	CMP top_page
	BNE main_loop
	LDA #HI(buff_page)
	STA load_page
	JMP main_loop
	
.end_game
{\\restore escape status
	LDA #%00000100;				check if bit 2 set
	BIT old_event_status
	BNE leave_esc_set
	LDA #&0D;					disable event
	LDX #6;						escape event code
	LDY #0;						because AUG says this is required
	JSR osbyte
.leave_esc_set
	
\\restore character event status
	LDA #%00100000;				check if bit 5 set
	BIT old_event_status
	BNE leave_char_event_set
	LDA #&0D;					disable event
	LDX #2;						character event code
	LDY #0;						because AUG says this is required
	JSR osbyte
.leave_char_event_set
	
\\restore timer zero event status
	LDA #%00000001;				check if bit 0 set
	BIT old_event_status
	BNE leave_timer_event_set
	LDA #&0D;					disable event
	LDX #5;						timer event code
	LDY #0;						because AUG says this is required
	JSR osbyte
.leave_timer_event_set
	
\\restore vsync event status
	LDA #%00000010;				check if bit 1 set
	BIT old_event_status
	BNE leave_vsync_event_set
	LDA #&0D;					disable event
	LDX #4;						vsync event code
	LDY #0;						because AUG says this is required
	JSR osbyte
.leave_vsync_event_set
	
\\restore EVNTV
	LDA evntv_old
	STA evntv
	LDA evntv_old+1
	STA evntv+1
	
\\turn off YM3812 timer
	LDA #&04					
	STA ymaddr
	LDA #&60
	STA ymdata

\\close file - this is going to generate a 'Handle' error if we loaded the whole file - nope, apparently it's OK
	LDA #0;					CLOSE
	LDY control_file_handle
	JSR osfind

\\restore IRQV
	SEI
	LDA irq1v_old
	STA irq1v
	LDA irq1v_old+1
	STA irq1v+1
	CLI

\\re-enable ADC sampling
	LDA #&10
	LDX old_ADC
	JSR osbyte
	
\\clean-up bottom row
{
	LDA #0
	LDX #40
.loop
	DEX
	STA bottom_row, X
	BNE loop
}	

\\recover all the registers	
	PLA:TAY:PLA:TAX:PLA:PLP
	
	RTS; goodbye
}	
\\YM3812 flush
.flush
	LDX #0
	LDA #0
.flush_loop
	NOP:NOP:NOP:NOP:NOP:NOP:NOP:NOP:NOP:NOP:NOP:NOP:NOP:NOP:NOP:NOP:NOP:NOP:NOP:NOP:NOP; need a delay of at least 47 cycles before writing to YMADDR
	STX ymaddr
	NOP:NOP:NOP:NOP; need a delay of at least 7 cycles before writing to YMDATA
	STA ymdata
	INX
	BNE flush_loop
	RTS

\\INCLUDES FOR ALL THE SUBROUTNES	
INCLUDE "src\jukebox\player.s.6502"
INCLUDE "src\jukebox\juke_event.s.6502"
INCLUDE "src\jukebox\juke_error.s.6502"
INCLUDE "src\jukebox\long_division.s.6502"
INCLUDE "src\jukebox\juke_subroutines.s.6502"

\\SETUP  MEMORY BLOCKS
.check_signature
	EQUS "DBRAWOPL"

.control_block
.control_file_handle; 	1 byte
	EQUB &00
.control_mem_addr;		4 bytes
	EQUB &00
.control_load_page
	EQUB HI(head_page)
	EQUW &0000
.control_bytes_to_read; 4 bytes
	EQUB &00
.control_pages_to_read
	EQUB &00
	EQUW &0000
.control_ptr
	EQUD &00000000;		4 bytes

.end

\\variables
.column
	EQUB &00
.minutes
	EQUB &00
.seconds
	EQUB &00
.hundredths
	EQUB &00
.duration
	EQUD &00000000
	EQUB &00
.old_ADC
	EQUB &00
.old_event_status
	EQUB &00;											Bit 0 - set if timer zero event was enabled before entry
													;	Bit 1 - set if vsync event was enabled before entry
													;	Bit 2 - set if escape was enabled before entry
													;	Bit 3 - set if
													;	Bit 4 - set if
													;	Bit 5 - set if character event was enabled before entry
													;	Bit 6 - set if
													;	Bit 7 - set if

\\dummy parameter block for osfile
.osfile_block
.osfile_filename_address
	EQUW &0000
.osfile_load_address
	EQUD &00000000
.osfile_load_indicator
.osfile_exec_adresss
	EQUD &00000000
.osfile_length
	EQUD &00000000
.osfile_lock_status
	EQUB &00

ALIGN &100
.head_page;							This page contains the standard DRO header, plus the first few bytes of the music
\\dummy header
.signature
	EQUS "DBRAWOPL"
.version_major
	EQUW &0002
.version_minor
	EQUW &0000
.length_pairs
	EQUD &00000000;					Length of data in pairs (i.e. one YMADDR and one YMDATA would be measured as "1" pair)
.length_MS
	EQUD &00000000;					Length of the tune in milliseconds
.hardware_type
	EQUB &00;						0=OPL2, 1=DUAL OPL2, 2=OPL3
.format
	EQUB &00;						0=data commands and data interleaved, no other vzriants known
.compression
	EQUB &00;						0= no compression, no other variants known
.short_delay_code
	EQUB &00;						Code for delays of 256ms or less
.long_delay_code
	EQUB &00;	 					Code for delays of greater than 256ms (calculated in 256ms chunks)
.cmd_table_size
	EQUB &00;						Length in bytes of the command table
.cmd_table;							The command table is always located &1A bytes into the header
								;	Since the max size of the command table is &80 bytes, the music will begin at the most at &9A
ALIGN &100
.buff_page;							This is where the circular buffer (proper) starts. head_page must not be overwritten, because it contains the command table

SAVE "JUKPLAY", start, end
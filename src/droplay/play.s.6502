.irq_handler
	LDA &FC:PHA:TXA:PHA:TYA:PHA
\\check if this interrupt is for us
\\both bits 6 and 7 of the status byte should be set
	BIT ymaddr;						both V (bit 6) and N (bit 7) should now be set
	BPL done_irq;					branch if N=0
	BVC done_irq;					branch of V=0

\\reset IRQ
	LDA #&04
	STA ymaddr
	LDA #&80
	STA ymdata

\\check if end of tune or lapped loader or escape key pressed
	LDA #%00001110;					test bit 1 (end of tune); bit 2 (lapped loader); bit 3 (escape)
	BIT flags
	BNE done_irq;					branch if result is not zero (i.e. end of tune flag is set)

\\============================================================================
\\check for non zero delay
\\THIS IS INEFFICIENT CODE - WE TEST THE SAME THING TWICE
	LDA delay;						get LSB of delay
	BNE decrement_delay;			and if it is not zero proceed to decrement
	LDA delay+1;					get LSB of delay
	BEQ player;						and if it is zero we should be playing tones

.decrement_delay
	LDA delay;						zero flag conditioned by LDA
	BNE lsb_delay_dec;				if not zero, only LSB needs to be decremented
	DEC delay+1;					decrement MSB
.lsb_delay_dec
	DEC delay;						decrement LSB
\\============================================================================

.done_irq
	PLA:TAY:PLA:TAX:PLA:STA &FC
	JMP (irq1v_old)

.player
\\============================================================================
\\THIS CODE IS SEEMS INEFFICIENT
{
	LDA #%00000001;					test bit 0 (EOF)
	BIT flags
	BEQ not_end_of_tune;			branch if result is zero (i.e. not EOF)
	
\\if we have reached EOF, have we also reached end of tune
	LDA mem_ptr;					check LSB of mem_ptr
	CMP tune_end;					against LSB of tune_end
	BNE not_end_of_tune
	LDA mem_ptr+1;					check MSB of mem_ptr
	CMP tune_end+1;					against MSB of tune_end
	BNE not_end_of_tune

\\set the end of tune flag
	LDA flags
	ORA #%00000010;					set bit 1 (end of tune)
	STA flags
	JMP done_irq
	
.not_end_of_tune
}
\\============================================================================

\\get next command
	LDY #0 
	LDA (mem_ptr),Y;			get first byte
	
\\check if this is an instruction to set up a new delay
\\first check if it is a short delay
	CMP short_delay_code
	BEQ short_delay

\\then check if it is a long delay
	CMP long_delay_code
	BEQ long_delay
	
\\if it isn't a delay it must be a command code
	TAX;									put the value into X to use it as an offset in the command table
	LDA cmd_table, X;						get the register address from the command table
	STA ymaddr;								and send it to ymaddr
	
	INY;									proceed to the next byte 
	LDA (mem_ptr),Y
	STA ymdata;								and place it in ymdata
	
\\next we have to increment mem_ptr by two
{
	INC mem_ptr
	INC mem_ptr
	BNE player;						if that didn't result in zero we haven't crossed a page boundary and can go round the player again
								;	what if mem_ptr started on an odd number? in practice it never has
								; 	NEED TO DEAL WITH THE POSSIBILITY OF ODD NUMBERS (I have set up an error routine for this for the time being)
	INC mem_ptr+1

\\check if we have reached top_page and have to go back to the bottom of the circular buffer	
	LDA mem_ptr+1
	CMP top_page;				if mem_ptr has reached top_page, we need to go back to the beginning of the circular buffer
	BNE not_at_top_page
	LDA #HI(buff_page)
	STA mem_ptr+1
.not_at_top_page
	
\\check if player has lapped loader
\\has mem_ptr just moved on from head_page?
	BIT flags;					bit 6 (the head_page flag) is now in V
	BVC check_if_in_load_page;	branch if V=0 (i.e. mem_ptr has not just left head_page)
	LDA flags
	AND	#%10111111;				clear bit 6
	STA flags
	JMP done_irq

.check_if_in_load_page
\\A already contains mem_ptr+1
	CMP load_page
	BNE player;					if we haven't reached load page we are safe to go around again
\\need to check if we have reached EOF
\\because, if we have, we don't need to worry about loading
	LDA #%00000001;				test bit 0 (EOF)
	BIT flags
	BNE player;					branch if result is not zero (i.e. we have reached EOF)

	LDA flags
	ORA #%00000100;				set bit 2 to confirm that we have lapped the loader
	STA flags
	JMP done_irq;				load_page represents a location where there is going to be, but has not yet been a load
							;	therefore, there is no point in going round the player again, 
							;	because what there is to play is not relevant
}	
\\====================================================================================
\\The remainder of this routine deals with setting up a new delay (if there is one)


\\First we deal with a short delay
\\The length of this delay is (n+1)ms
.short_delay
{
	INY;							Y now points to the delay byte
	CLC
	LDA #1;							always have to add 1 to the delay
	ADC (mem_ptr), Y
	STA delay
	BCC increment_mem_ptr_new_delay
	LDA #1
	STA delay+1
\\halve delay because of fewer interrupts
	\ LSR delay+1
	\ ROR delay
	JMP increment_mem_ptr_new_delay
}

\\For a long delay, the length is ((n+1)*256)ms
	.long_delay
	LDA #0
	STA delay
	INY;							Y now points to the delay byte

\\WHICH OF THE FOLLOWING USES MORE CODE/IS FASTER?	
	\ CLC
	\ LDA #1;							always have to add 1 to the delay
	\ ADC (mem_ptr), Y
	\ STA delay+1
	
	LDA (mem_ptr), Y
	STA delay+1
	INC delay+1
\\halve delay because of fewer interrupts
	\ LSR delay+1
	\ ROR delay	

\\Finally, just like with the main player routine, we need to increment mem_ptr
\\We could save code space by doing this as a subroutine
\\But repeating it, could save execution time
.increment_mem_ptr_new_delay
{
	INC mem_ptr
	INC mem_ptr
	BEQ inc_mem_ptr_msb
	JMP done_irq;					if that didn't result in zero we haven't crossed a page boundary
								;	what if mem_ptr started on an odd number? in practice it never has
								; 	NEED TO DEAL WITH THE POSSIBILITY OF ODD NUMBERS (I have set up an error routine for this for the time being)
.inc_mem_ptr_msb
	INC mem_ptr+1

\\check if we have reached top_page and have to go back to the bottom of the circular buffer	
	LDA mem_ptr+1
	CMP top_page;				if mem_ptr has reached top_page, we need to go back to the beginning of the circular buffer
	BNE not_at_top_page
	LDA #HI(buff_page)
	STA mem_ptr+1
.not_at_top_page
	
\\check if player has lapped loader
\\has mem_ptr just moved on from head_page?
	BIT flags;					bit 6 (the head_page flag) is now in V
	BVC check_if_in_load_page;	branch if V=0 (i.e. mem_ptr has not just left head_page)
	LDA flags
	AND	#%10111111;				clear bit 6
	STA flags
	JMP done_irq

.check_if_in_load_page
\\A already contains mem_ptr+1
	CMP load_page;				load_page represents a location where there is going to be, but has not yet been a load
	BEQ check_eof
	JMP done_irq

\\need to check if we have reached EOF
\\because, if we have, we don't need to worry about loading
.check_eof
	LDA #%00000001;				test bit 0 (EOF)
	BIT flags
	BNE skip_lapped_flag;		branch if result is not zero (i.e. we have reached EOF)

	LDA flags
	ORA #%00000100;				set bit 2 to confirm that we have lapped the loader
	STA flags

.skip_lapped_flag	
	JMP done_irq
}
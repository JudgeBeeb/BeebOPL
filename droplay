ORG &0400;

\\constants
ymaddr=&FC04
ymdata=&FC05
load_page=&0E
irq2v=&206
short_delay_code=(load_page*256)+&17
long_delay_code=(load_page*256)+&18
cmd_table_size=(load_page*256)+&19
cmd_table=(load_page*256)+&1A

IER=&FE6E;		 	user Interrupt Enable Register
T1C_L=&FE64;		user T1 low order latch
T1C_H=&FE65;		user T1 high order latch
ACR=&FE6B;			user Auxiliary Control Register
IPTFR=&FE6D;		user Interrupt Flag Register



\ osbget=&FFD7
\ osargs=&FFDA
\ osfind=&FFCE
\ osgbpb=&FFD1

\ top_address=&30


\ end_ptr=&74;			(&74 and &75)
\ next_page=&78
\ flags=&7A; 				bit 0 set if all of file is read, bit 1 set if LSB of end_ptr reached, bit 2 set if MSB of end_ptr reached 
\ file_handle=&7B
\ ext=&7C;				(&7C, &7D, &7E, &7F)
\ filename_address=&80;	(&80, &81)


\ grab_delay=100;		50 for 280Hz; 100 for 560Hz; 125 for 700Hz


\\zero page variablse
irq2v_old=&70;			(&70 and &71)
mem_ptr=&72;			(&72 and &73)
delay=&74;				(&74 and &75)
addr=&76


.start
	
	PHP:PHA:TXA:PHA:TYA:PHA;		preserve all the registers on the stack
		
\\get filename	
	\ LDA #1
	\ LDX #filename_address
	\ LDY #0
	\ JSR osargs

\\setup delay
	LDA #0
	STA delay
	STA delay+1
	
\\intercept interrupts
	SEI;							disable interrupts
	LDA irq2v;						preserve existing IRQV
	STA irq2v_old
	LDA irq2v+1
	STA irq2v_old+1
	LDA #LO(irq_handler);			redirect IRQV to our IRQ handler
	STA irq2v
	LDA #HI(irq_handler)
	STA irq2v+1
	
\\setup timer
	LDA #&40 \\ disable T1 interrupts (0 in bit 7, 1 bit 6)
	STA IER
	CLI \\ re-enable interrupts 
	LDA #LO(1000)
	STA T1C_L
	LDA #HI(1000);		put this value in the T1 latch
	STA T1C_H
	LDA #&C0 \\ enable T1 interrupts (1 in bit 7, 1 bit 6)
	STA IER
	LDA ACR \\ get the content of ACR
	ORA #&40 \\ set T1 free running mode
	STA ACR

\ \\open file	
	\ LDA #&40;				OPENIN
	\ LDX filename_address
	\ LDY filename_address+1
	\ JSR osfind
	\ BNE file_opened
	\ BRK
\ .file_opened
	\ STA file_handle
	\ STA control_file_handle

\ \\get EXT#
	\ TAY;					put file handle in Y
	\ LDX #ext
	\ LDA #2
	\ JSR osargs
	
\ \\initialize end_ptr
	\ LDA ext
	\ STA end_ptr;			put LSB of ext in LSB of end_ptr
	\ LDA #0
	\ STA end_ptr+1
	
\initialize mem_ptr
	CLC
	LDA #LO(cmd_table)
	ADC cmd_table_size
	STA mem_ptr
	LDA #HI(cmd_table)
	ADC #0
	STA mem_ptr+1
	
\ \\initialize flags
	\ LDA #0
	\ STA flags
	
\ \\initialize next_page
	\ LDA #load_address
	\ STA next_page
	
\ \\fill_memory
	\ LDA #4;					read block using PTR#
	\ LDX #LO(control_block)
	\ LDY #HI(control_block)
	\ \\the other values are already pre-programmed in the control block
	\ CLC
	\ JSR osgbpb
	\ BCC loop
\ \\handle EOF
	\ LDA flags
	\ ORA #%00000001;			set bit 0
	\ STA flags
	\ LDA control_mem_addr+1; on return, control_mem_addr contains the value of end_ptr
	\ STA end_ptr+1
	
.loop
\\deal with the 4 bytes
	LDY #0 
	LDA (mem_ptr),Y;		get byte for YMADDR
	CMP short_delay_code
	BNE not_single_delay
	JMP single_delay
.not_single_delay
	CMP long_delay_code
	BNE not_double_delay
	JMP double_delay
.not_double_delay
	\ CMP #2
	\ BNE not_code_2
	\ INC mem_ptr
	\ BNE loop
	\ INC mem_ptr+1
	\ JMP loop
\ .not_code_2
	\ CMP #3
	\ BNE not_code_3
	\ INC mem_ptr
	\ BNE loop
	\ INC mem_ptr+1
	\ JMP loop
\ .not_code_3
	\ CMP #4
	\ BNE not_escape_code
	\ INC mem_ptr
	\ BNE done_escape_code
	\ INC mem_ptr+1
\ .done_escape_code
	\ LDA (mem_ptr), Y
\ .not_escape_code
	TAX
	LDA cmd_table, X
	STA	addr;				preserve incase there is an interrupt
	STA ymaddr
	INY
	LDA (mem_ptr),Y;		get byte for YMDATA
	STA ymdata
	\ INY
	\ LDA (mem_ptr),Y;		get LSB of delay
	\ STA delay
	\ INY
	\ LDA (mem_ptr),Y;		get MSB of delay
	\ STA delay+1

.increment_mem_ptr
	\ LDA flags
	\ AND #%11111001;			clear bits 1 and 2 of flags
	\ STA flags
	LDA mem_ptr
	CLC
	ADC #2;					increment the LSB of the pointer
	STA mem_ptr
	\ PHP;					push P onto the stack, because the CMP will affect the carry flag
	\ CMP end_ptr;			is it the same as LSB of end_ptr?
	\ BNE mem_ptr_msb
	\ LDA flags
	\ ORA #%00000010;			set bit 1 of flags
	\ STA flags
\ .mem_ptr_msb
	\ PLP;					pull P back from the stack so that the arithmetic on MSB will work
	LDA mem_ptr+1
	ADC #0
\ \\have we crossed a page boundary?
	\ CMP mem_ptr+1
	\ BEQ no_boundary_crossed
\ \\if so, need to check if we are going to overtake next_page
	\ CMP next_page
	\ BNE timing_ok
	\ PHA
	\ JSR grab_page
	\ PLA
\ .timing_ok
	STA mem_ptr+1
\ .no_boundary_crossed
	\ CMP end_ptr+1
	\ BNE check_top_address
	\ LDA flags
	\ ORA #%00000100;			set bit 2 of  flags
	\ STA flags
	\ LDA mem_ptr+1
\ .check_top_address
	\ CMP #top_address
	\ BNE check_done_flags
	\ LDA #load_address;		reset mem_ptr to load_address (HOW DO I CHECK WE HAVE ALREADY FILLED THIS PAGE AGAIN?)
	\ STA mem_ptr+1
\ .check_done_flags
	\ LDA flags
	\ AND #%00000111;			check all three bits set
	\ CMP	#%00000111
	\ BEQ finish
	
.wait_loop
	\ LDA delay+1; 		compare high bytes
    \ BNE grab;			if it is non-zero we definitely have time for a grab
    \ LDA delay; 			compare low bytes
    \ CMP #grab_delay
	\ BCC no_grab; 		if delay less than grab_delay there isn't enough time for a grab
\ .grab
	\ JSR grab_page
\ .no_grab
	LDA delay;			get LSB of delay
	BNE wait_loop;		and if it is not zero continue waiting 
	LDA delay+1;		get MSB of delay
	BNE wait_loop;		and if it is not zero continue waiting
	JMP loop;

\ .grab_page
	\ LDA next_page
	\ CMP mem_ptr+1;		is mem_ptr in the same page? (mem_ptr can't overtake next_page)
	\ BEQ finish_grab;	if so, we can't do a write
	\ LDA flags
	\ AND #%00000001;		check bit 0, have we already reached EOF
	\ CMP	#%00000001
	\ BEQ finish_grab
	\ LDA file_handle
	\ STA control_file_handle
	\ LDA next_page
	\ STA control_mem_addr+1
	\ LDA #0
	\ STA control_mem_addr
	\ STA control_mem_addr+2
	\ STA control_mem_addr+3
	\ STA control_bytes_to_read
	\ STA control_bytes_to_read+2
	\ STA control_bytes_to_read+3
	\ LDA #1
	\ STA control_bytes_to_read+1
	\ LDA #4;					read block using PTR#
	\ LDX #LO(control_block)
	\ LDY #HI(control_block)
	\ CLC
	\ JSR osgbpb
	\ BCC not_eof

\ \\handle EOF
	\ LDA flags
	\ ORA #%00000001;			set bit 0
	\ STA flags
	\ LDA control_mem_addr+1; on return, control_mem_addr contains the value of end_ptr
	\ STA end_ptr+1

\ .not_eof
	\ INC next_page
	\ LDA next_page
	\ CMP #top_address
	\ BNE finish_grab
	\ LDA #load_address
	\ STA next_page
	
\ .finish_grab
	\ RTS

\ .finish
	
\ \\turn off timer
	\ LDA #&04					
	\ STA ymaddr
	\ LDA #&60
	\ STA ymdata

\ \\close file
	\ LDA #0;					CLOSE
	\ LDY file_handle
	\ JSR osfind

\ \\restore IRQ2V
	\ SEI
	\ LDA irq2v_old
	\ STA irq2v
	\ LDA irq2v_old+1
	\ STA irq2v+1
	\ CLI
	
\ \\restore registers
	\ PLA:TAY:PLA:TAX:PLA:PLP
	
	\ RTS;					goodbye

.irq_handler
	LDA &FC:PHA:TXA:PHA:TYA:PHA 
	\ LDA ymaddr;						get status byte
	\ AND #&E0;						mask all but bits 7 and 6 (should be &C0?)
	\ BEQ done_decrement;				if bits 6 and 7 not set, this interrupt is not for us

	LDA IPTFR \\ get interrupt flag register
	AND #&40 \\ mask all but bit 6
	BEQ done_decrement \\ if bit 6 not set, this interrupt is not for us
	LDA #&40
	STA IPTFR \\ clear T1 interrupt flag
	
\ \\reset IRQ
	\ LDA #&04					
	\ STA ymaddr
	\ LDA #&80
	\ STA ymdata
	
\\restore last setting of YMADDR
	LDA addr
	STA ymaddr

\\decrement delay
	LDA delay;						get LSB of delay
	BNE decrement;					and if it is not zero proceed to decrement
	LDA delay+1;					get MSB of delay 
	BEQ done_decrement;				and if it is zero no need to decrement
.decrement
	SEC;							set the carry for a decrement
	LDA delay;						decrement LSB
	SBC #1
	STA delay
	BCS done_decrement
	DEC delay+1;					decrement MSB

.done_decrement
	PLA:TAY:PLA:TAX:PLA:STA &FC
	JMP (irq2v_old)
	
.single_delay
	SEI
	LDA #0
	STA delay+1
	INY;							Y now points to the delay byte
	CLC
	LDA #1;							always have to add 1 to the delay
	ADC (mem_ptr), Y
	STA delay
	BCC single_delay_skip
	INC delay+1
.single_delay_skip
	\ CLC;							multiply delay by two
	\ ASL delay
	\ ROL delay+1
	\ LDA (mem_ptr), Y;				add  a further 0.5
	\ LSR A
	\ STA (mem_ptr), Y
	\ CLC
	\ LDA delay
	\ ADC (mem_ptr), Y
	\ STA delay
	\ BCC single_delay_half_skip
	\ INC delay+1
.single_delay_half_skip
	CLI
	JMP increment_mem_ptr
	
.double_delay
	SEI
	LDA #0
	STA delay
	INY;							Y now points to the delay byte
	CLC
	LDA #1;							always have to add 1 to the delay
	ADC (mem_ptr), Y
	STA delay+1
	\ INY;							Y now points to the MS delay byte
	\ LDA delay+1
	\ ADC (mem_ptr), Y
	\ STA delay+1
	\ CLC;
\\multiply delay by two
	\ ASL delay
	\ ROL delay+1
\ \\add a further 0.5 to delay
	\ LDA (mem_ptr), Y;				Y still points to the MS delay byte
	\ LSR A
	\ STA (mem_ptr), Y
	\ DEY;							Y now points to the LS delay byte
	\ LDA (mem_ptr), Y
	\ ROR A
	\ STA (mem_ptr), Y
	\ CLC
	\ LDA delay
	\ ADC (mem_ptr), Y;				Y still points to the LS delay byte
	\ STA delay
	\ INY;							Y now points to the MS delay byte
	\ LDA delay+1
	\ ADC (mem_ptr), Y
	\ STA delay+1
\ \\increment mem_ptr because a double delay includes an extra byte
	\ INC mem_ptr
	\ BNE done_double_delay
	\ INC mem_ptr+1
.done_double_delay	
	CLI
	JMP increment_mem_ptr
	
\ .filename
	\ EQUS "KISS"
	\ EQUB &0D
\ .filename_address
	\ EQUW filename
	
\ .control_block
\ .control_file_handle; 	1 byte
	\ EQUB &00
\ .control_mem_addr;		4 bytes
	\ EQUB &00
	\ EQUB load_address
	\ EQUW &0000
\ .control_bytes_to_read; 4 bytes
	\ EQUD &00001000
\ .control_ptr
	\ EQUD &00000000;		4 bytes
	
.end

SAVE "DROPLAY", start, end